<HTML>
<HEAD>
<TITLE>VOTABLE::Element - VOTABLE XML element class</TITLE>
<LINK REV="made" HREF="mailto:elwinter@olegacy.gsfc.nasa.gov">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#methods">Methods</A></LI>
		<UL>

			<LI><A HREF="#new($str_or_ref, %options)"><CODE>new($str_or_ref, %options)</CODE></A></LI>
		</UL>

	</UL>

	<LI><A HREF="#warnings">WARNINGS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#version">VERSION</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<HR>
<H1><A NAME="name">NAME</A></H1>
<P>VOTABLE::Element - VOTABLE XML element class</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<P><CODE>use VOTABLE::Element</CODE></P>
<P><CODE>$votable_element = new VOTABLE::Element</CODE></P>
<P><CODE>$votable_element = new VOTABLE::Element undef, a1 =&gt; v1, a2 =&gt; v2, ...</CODE></P>
<P><CODE>$votable_element = new VOTABLE::Element $xml_string</CODE></P>
<P><CODE>$votable_element = new VOTABLE::Element $xml_string, a1 =&gt; v1, a2 =&gt; v2, ...</CODE></P>
<P><CODE>$votable_element = new VOTABLE::Element $xmldom_element</CODE></P>
<P><CODE>$votable_element = new VOTABLE::Element $xmldom_element, a1 =&gt; v1, a2 =&gt; v2, ...</CODE></P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>This class is a VOTABLE-specific wrapper around the
<CODE>XML::DOM::Element</CODE> class. It provides the base functionality for all
VOTABLE element classes, and allows access to implementation-specific
details, such as <CODE>the XML::DOM::Element</CODE> objects embedded within the
VOTABLE objects. The typical user should never need access to the
implementation-specific details, so these base methods are for use
primarily by other VOTABLE objects. This approach was taken to allow
modification of the underlying XML technology (currently <CODE>XML::DOM</CODE>,
but we may use something else later) without changing the user API.</P>
<P>The overall design of the VOTABLE objects is straightforward. Each XML
element in the VOTABLE DTD is represented by a class. Each element
class is a subclass of <CODE>VOTABLE::Element</CODE> (this class). Within each
element class, there are attributes and child elements, along with
implementation-specific data, such as references to the underlying
<CODE>XML::DOM</CODE> objects.</P>
<P>Attributes are manipulated using <CODE>get_ATTNAME</CODE> and <CODE>set_ATTNAME</CODE>
methods (accessors), where <CODE>ATTNAME</CODE> is replaced by the name of the
attribute in question. The <CODE>set</CODE> methods take a single argument (the
value to set the attribute to), and the <CODE>get</CODE> methods take no
arguments. Since attributes can only take single values, all
<CODE>set_ATTNAME</CODE> methods take single scalars as arguments, and
<CODE>get_ATTNAME</CODE> methods return single scalars. All <CODE>set_ATTNAME</CODE>
methods return the newly-set value on success, or <CODE>undef</CODE> if an error
occurs.</P>
<P>Child elements have similar accessors, of the form <CODE>get_ELNAME</CODE> and
<CODE>set_ELNAME</CODE>, where <CODE>ELNAME</CODE> is replaced by the name of the element
(more precisely, the name of the element <EM>tag</EM>, such as <CODE>TABLEDATA</CODE>
for a <CODE>TABLEDATA</CODE> element). Note that these names, and the methods,
are case-sensitive. The type of arguments passed to and returned from
the element accessors is determined by the multiplicity of the child
elements (as defined by the VOTABLE DTD). Elements which can occur 0
or 1 times (those which are unquantified, or quantified with a '?' in
the DTD) are passed and returned as scalars, while elements which can
occur 1 or more times (those quantified with a '+' or '*' in the DTD)
are passed and returned as lists. Like <CODE>set_ATTNAME</CODE> accessors,
<CODE>set_ELNAME</CODE> accessors return the new <CODE>value(s)</CODE> on success. On
failure, scalar-returning methods return <CODE>undef</CODE>, while
list-returning methods return an empty list.</P>
<P>
<H2><A NAME="methods">Methods</A></H2>
<P>
<H3><A NAME="new($str_or_ref, %options)"><CODE>new($str_or_ref, %options)</CODE></A></H3>
<P>This is the class constructor. <CODE>$str_or_ref</CODE>, if defined, contains a
string of XML to use to initialize the new object, or a reference to
an existing <CODE>XML::DOM::Element</CODE> object to use to initialize the new
object. If <CODE>$str_or_ref</CODE> is undefined, a new, empty
<CODE>XML::DOM::Element</CODE> object is created for the new object. The
<CODE>%options</CODE> argument contains 0 or more <CODE>key =&gt; value</CODE> pairs to
use when setting the initial values of the element attributes. On
success, this method returns the blessed refrence for the new
object. On failure, this method returns <CODE>undef</CODE>.</P>
<P>
<HR>
<H1><A NAME="warnings">WARNINGS</A></H1>
<UL>
<LI>
This code (perhaps unwisely) assumes that object internal structure is
always maintained. For example, this code assumes that every
<CODE>VOTABLE::Element</CODE> <EM>always</EM> has an underlying <CODE>XML::DOM::Element</CODE>
object. When aberrant cases are encountered, an exception is raised
(using the <CODE>Carp::croak</CODE> subroutine).
<P></P>
<LI>
Similarly, this code assumes that <CODE>XML::DOM</CODE> methods always
succeed. When aberrant cases are encountered, an exception is raised
(using the <CODE>Carp::croak</CODE> subroutine).
<P></P>
<LI>
Attribute and element names containing embedded hyphens ('-') use
accessors where the hyphen is mapped to an underscore ('_') in the
name of the accessor method. This is a necessity, since the hyphen is
not a valid name character in Perl.
<P></P></UL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><EM>perl</EM>, <EM>XML::DOM</EM></P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Eric Winter, NASA GSFC (<A HREF="mailto:elwinter@milkyway.gsfc.nasa.gov">elwinter@milkyway.gsfc.nasa.gov</A>)</P>
<P>
<HR>
<H1><A NAME="version">VERSION</A></H1>
<P>$Id: Element.pm,v 1.1.1.4 2002/06/09 21:13:08 elwinter Exp $</P>

</BODY>

</HTML>
